diff --git a/app/Console/Commands/MonitorCertificatesCommand.php b/app/Console/Commands/MonitorCertificatesCommand.php
index 10a8b96..efe8a8b 100644
--- a/app/Console/Commands/MonitorCertificatesCommand.php
+++ b/app/Console/Commands/MonitorCertificatesCommand.php
@@ -7,7 +7,8 @@
 use App\Jobs\ScheduleCertificateRenewal;
 use App\Events\CertificateExpiring;
 use App\Services\EnhancedSSLSaaSService;
-use Illuminate\Support\Facades\{Log, Cache};
+use App\Notifications\SSLSystemAlertNotification;
+use Illuminate\Support\Facades\{Log, Cache, Notification};
 
 class MonitorCertificatesCommand extends Command
 {
@@ -31,6 +32,12 @@ public function handle(): int
         $this->info('ðŸ” Starting SSL Certificate Monitoring');
         $this->newLine();
 
+        // æ§‹é€ åŒ–ãƒ­ã‚°
+        Log::info('SSL Certificate Monitoring started', [
+            'command' => 'ssl:monitor-certificates',
+            'options' => $this->options()
+        ]);
+
         // Check if monitoring was recently run (prevent duplicate runs)
         if (!$this->option('force') && $this->wasRecentlyRun()) {
             $this->info('â­ï¸  Monitoring was recently run. Use --force to override.');
@@ -65,12 +72,20 @@ public function handle(): int
                 $stats['provider_issues'] = $providerStats['unhealthy_providers'];
             }
 
+            // ç•°å¸¸æ¤œçŸ¥ã¨Slacké€šçŸ¥
+            $this->detectAnomaliesAndNotify($stats);
+
             // Display summary
             $this->displaySummary($stats);
 
             // Update cache with monitoring results
             $this->cacheMonitoringResults($stats);
 
+            // æ§‹é€ åŒ–ãƒ­ã‚°
+            Log::info('SSL Certificate Monitoring completed', array_merge($stats, [
+                'status' => 'success'
+            ]));
+
             $this->info('âœ… Certificate monitoring completed successfully');
             return self::SUCCESS;
 
@@ -82,6 +97,18 @@ public function handle(): int
                 'trace' => $e->getTraceAsString()
             ]);
 
+            // é‡å¤§ã‚¨ãƒ©ãƒ¼ã®Slacké€šçŸ¥
+            $this->sendSlackAlert(
+                'SSL Monitoring System Error',
+                'SSL monitoring command failed with exception',
+                [
+                    'Error' => $e->getMessage(),
+                    'File' => $e->getFile() . ':' . $e->getLine(),
+                    'Command' => $this->signature
+                ],
+                'critical'
+            );
+
             return self::FAILURE;
         } finally {
             $this->markAsCompleted();
@@ -185,6 +212,7 @@ private function checkProviderHealth(): array
 
         $healthResults = $this->sslService->performHealthCheck();
         $unhealthyProviders = 0;
+        $providerDetails = [];
 
         foreach ($healthResults as $provider => $result) {
             $status = $result['status'] ?? 'unknown';
@@ -198,13 +226,117 @@ private function checkProviderHealth(): array
             
             if (in_array($status, ['failed', 'error'])) {
                 $unhealthyProviders++;
+                $providerDetails[$provider] = $result['error'] ?? 'Unknown error';
+                
                 if ($this->option('verbose') && isset($result['error'])) {
                     $this->line("      Error: {$result['error']}");
                 }
             }
         }
 
-        return ['unhealthy_providers' => $unhealthyProviders];
+        return [
+            'unhealthy_providers' => $unhealthyProviders,
+            'provider_details' => $providerDetails,
+            'health_results' => $healthResults
+        ];
+    }
+
+    /**
+     * ç•°å¸¸æ¤œçŸ¥ã¨Slacké€šçŸ¥
+     */
+    private function detectAnomaliesAndNotify(array $stats): void
+    {
+        if (!config('ssl-enhanced.monitoring.alert_on_failure', true)) {
+            return;
+        }
+
+        // å¤±æ•—ã—ãŸè¨¼æ˜Žæ›¸ã®æ¤œçŸ¥
+        if ($stats['failed_certificates'] > 0) {
+            $this->sendSlackAlert(
+                'Certificate Failures Detected',
+                "Found {$stats['failed_certificates']} failed certificates that require attention",
+                [
+                    'Failed Certificates' => $stats['failed_certificates'],
+                    'Total Certificates' => $stats['total_certificates'],
+                    'Failure Rate' => round(($stats['failed_certificates'] / max($stats['total_certificates'], 1)) * 100, 1) . '%'
+                ],
+                'error'
+            );
+        }
+
+        // å¤§é‡ã®æœŸé™åˆ‡ã‚Œé–“è¿‘è¨¼æ˜Žæ›¸ã®æ¤œçŸ¥
+        $expiringThreshold = 10; // è¨­å®šå¯èƒ½ã«ã™ã‚‹
+        if ($stats['expiring_certificates'] > $expiringThreshold) {
+            $this->sendSlackAlert(
+                'Many Certificates Expiring Soon',
+                "Warning: {$stats['expiring_certificates']} certificates expiring within {$this->option('days')} days",
+                [
+                    'Expiring Soon' => $stats['expiring_certificates'],
+                    'Auto Renewal Scheduled' => $stats['renewals_scheduled'],
+                    'Threshold' => $expiringThreshold
+                ],
+                'warning'
+            );
+        }
+
+        // ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãƒ˜ãƒ«ã‚¹ã®å•é¡Œæ¤œçŸ¥
+        if ($stats['provider_issues'] > 0) {
+            $this->sendSlackAlert(
+                'SSL Provider Health Issues',
+                "{$stats['provider_issues']} SSL providers are experiencing connectivity or health issues",
+                [
+                    'Unhealthy Providers' => $stats['provider_issues'],
+                    'Impact' => 'New certificate issuance may be affected'
+                ],
+                'critical'
+            );
+        }
+
+        // æˆåŠŸæ™‚ã®å®šæœŸå ±å‘Šï¼ˆ1æ—¥1å›žï¼‰
+        if ($this->shouldSendDailyReport($stats)) {
+            $this->sendSlackAlert(
+                'SSL System Daily Report',
+                'SSL monitoring system is running normally',
+                [
+                    'Total Certificates' => $stats['total_certificates'],
+                    'Expiring Soon' => $stats['expiring_certificates'],
+                    'Failed Certificates' => $stats['failed_certificates'],
+                    'Renewals Scheduled' => $stats['renewals_scheduled']
+                ],
+                'success'
+            );
+        }
+    }
+
+    /**
+     * Slacké€šçŸ¥é€ä¿¡
+     */
+    private function sendSlackAlert(string $title, string $message, array $details = [], string $severity = 'warning'): void
+    {
+        try {
+            if (!config('services.slack.notifications.webhook_url')) {
+                Log::warning('Slack webhook URL not configured, skipping alert', [
+                    'title' => $title,
+                    'severity' => $severity
+                ]);
+                return;
+            }
+
+            Notification::route('slack', config('services.slack.notifications.webhook_url'))
+                ->notify(new SSLSystemAlertNotification($title, $message, $details, $severity));
+                
+            Log::info('Slack alert sent successfully', [
+                'title' => $title,
+                'severity' => $severity,
+                'details_count' => count($details)
+            ]);
+        } catch (\Exception $e) {
+            Log::error('Failed to send Slack alert', [
+                'error' => $e->getMessage(),
+                'title' => $title,
+                'severity' => $severity
+            ]);
+        }
     }
 
     /**
@@ -369,4 +501,27 @@ private function calculateHealthStatus(array $stats): string
 
         return 'healthy';
     }
+
+    /**
+     * 1æ—¥1å›žã®å®šæœŸå ±å‘ŠãŒå¿…è¦ã‹ãƒã‚§ãƒƒã‚¯
+     */
+    private function shouldSendDailyReport(array $stats): bool
+    {
+        // æ¯Žæ—¥6æ™‚ã«ã®ã¿é€ä¿¡ï¼ˆè¨­å®šå¯èƒ½ï¼‰
+        $reportHour = config('ssl-enhanced.monitoring.daily_report_hour', 6);
+        if (now()->hour !== $reportHour) {
+            return false;
+        }
+
+        // ä»Šæ—¥æ—¢ã«é€ä¿¡æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
+        $lastReportDate = Cache::get('ssl_daily_report_last_sent');
+        if ($lastReportDate && $lastReportDate === now()->toDateString()) {
+            return false;
+        }
+
+        // å ±å‘Šé€ä¿¡ã‚’ãƒžãƒ¼ã‚¯
+        Cache::put('ssl_daily_report_last_sent', now()->toDateString(), now()->addDays(2));
+        
+        return true;
+    }
 }
\ No newline at end of file
